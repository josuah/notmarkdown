#!/usr/bin/awk -f
# convert a notmarkdown document to html format

# For each line of input, if still part of the same block, it append it to the
# current line LINE[N], and if not, it pushes a new line to the array LINE[++N].
#
# That is the first pass of parsing: turn a line-based syntax (HTML's blocks
# element) into an array of single-line syntax (HTML's inline elements).

BEGIN {
	HEADER = 1
}

# Now that we parsed all the block-specific structure we are done with the 
# input: every markdown block is in its own entry in the LINE[] array.
#
# Now remains to print the blocks one by one, converting the inline elements
# as we go.

function html_escape(s)
{
	gsub("&",  "\\&amp;",  s)
	gsub("<",  "\\&lt;",   s)
	gsub(">",  "\\&gt;",   s)
	gsub("\"", "\\&quot;", s)
	return s
}

# If the previous TAG is not the same as thte current t tag, close the previous 
# and open the next.

function print_hook(s, tag)
{
	if (TAG != tag) {
		if (TAG) print("</"TAG">")
		if (tag) print("<"tag">")
	}
	TAG = tag
	return html_escape(s)
}

function convert_links(s,
	tail, name, ref)
{
	tail = s
	s = ""
	while (match(tail, /\[[^]]*\]/)) {
		s = s substr(tail, 1, RSTART - 1)
		ref = tolower(substr(tail, RSTART + 1, RLENGTH - 2))
		s = s sprintf("<a href=\"%s\">%s</a>", LINK[ref], TEXT[ref])
		tail = substr(tail, RSTART + RLENGTH)
	}
	return s tail
}

function convert_images(s,
	tail, name, ref)
{
	tail = s
	s = ""
	while (match(tail, /!\[[^]]*\]/)) {
		s = s substr(tail, 1, RSTART - 1)
		ref = tolower(substr(tail, RSTART + 2, RLENGTH - 3))
		s = s sprintf("<img src=\"%s\" alt=\"%s\"/>", LINK[ref], TEXT[ref])
		tail = substr(tail, RSTART + RLENGTH)
	}
	return s tail
}

function convert_syntax(s, reg, len, tag,
	tail)
{
	tail = s
	s = ""
	while (match(tail, reg)) {
		s = s substr(tail, 1, RSTART - 1)
		s = s "<"tag">"
		s = s substr(tail, RSTART + len, RLENGTH - len * 2)
		s = s "</"tag">"
		tail = substr(tail, RSTART + RLENGTH)
	}
	return s tail
}

# **bold**, *italics*, links...

function convert_text(s)
{
	s = convert_syntax(s, "[*][*][^ ][^*]*[^ ][*][*]", 2, "strong")
	s = convert_syntax(s, "[*][^ ][^*]*[^ ][*]", 1, "em")
	s = convert_images(s)
	s = convert_links(s)
	return s
}

# Match the beginning of the line using the regexes REG[] defined in BEGIN
# to determine the printer to use.

HEADER && /^$/ {
	HEADER = 0
	next
}

HEADER {
	LINK[$1] = $2
	TEXT[$1] = $0
	sub("^[^ ]+ [^ ]* ", "", TEXT[$1])
	next
}

sub("^\t", "", $0) {
	$0 = print_hook($0, "pre")
	print($0)
	next
}

sub("^\\* ", "", $0) {
	$0 = print_hook($0, "ul")
	printf("<li>%s</li>\n", convert_text($0))
	next
}

sub("^[0-9]+. ", "", $0) {
	$0 = print_hook($0, "ol")
	printf("<li>%s</li>\n", convert_text($0))
	next
}

match($0, "^#+ ") {
	$0 = print_hook(substr($0, RLENGTH + 1))
	lv = RLENGTH - 1
	printf("\n\n<h%d>%s</h%d>\n\n", lv, convert_text($0), lv)
	next
}

sub("^> ", "", $0) {
	$0 = print_hook($0, "blockquote")
	printf("%s\n", convert_text($0))
	next
}

{
	$0 = print_hook($0, "")
	printf("<p>%s</p>\n", convert_text($0))
}

END {
	print_hook("", "")
}
