#!/usr/bin/awk -f
# convert a notmarkdown document to html format

# For each line of input, if still part of the same block, it append it to the
# current line LINE[N], and if not, it pushes a new line to the array LINE[++N].
# That is the first pass of parsing: turn a line-based syntax (HTML's blocks
# element) into an array of single-line syntax (HTML's inline elements).

BEGIN {
	HEADER = 1

	TYPE["jpg"] = TYPE["jpeg"] = TYPE["png"] = TYPE["gif"] = "picture"
	TYPE["mkv"] = TYPE["webm"] = TYPE["avi"] = TYPE["mp4"] = "video"
	TYPE["mka"] = TYPE["opus"] = TYPE["wav"] = TYPE["mp3"] = "audio"
	TYPE["flac"] = TYPE["ogg"] = "audio"
}

# If the previous TAG is not the same as thte current t tag, close the previous 
# and open the next.

function print_hook(s, tag)
{
	if (TAG != tag) {
		if (TAG) print("</"TAG">")
		if (tag) print("<"tag">")
	}
	TAG = tag
}

function convert_links(s,
	head, tail, ref)
{
	head = ""
	tail = s
	while (match(tail, /\[[^] ]+\]/)) {
		head = head substr(tail, 1, RSTART - 1)
		ref = tolower(substr(tail, RSTART + 1, RLENGTH - 2))
		head = head sprintf("<a href=\"%s\">%s</a>", LINK[ref], TEXT[ref])
		tail = substr(tail, RSTART + RLENGTH)
	}
	return head tail
}

function media(link, alt,
	ext, type)
{
	ext = link
	sub(/.*\./, "", ext)
	if ((type = TYPE[ext]) == "" || type == "picture")
		return sprintf("<img src=\"%s\" alt\"%s\"/>", link, alt)
	return sprintf("<%s controls> <source src=\"%s\"/> %s </%s>",
	  type, link, alt, type)
}

function convert_media(s,
	head, tail, ref)
{
	head = ""
	tail = s
	while (match(tail, /!\[[^] ]+\]/)) {
		head = head substr(tail, 1, RSTART - 1)
		ref = tolower(substr(tail, RSTART + 2, RLENGTH - 3))
		head = head media(LINK[ref], TEXT[ref])
		tail = substr(tail, RSTART + RLENGTH)
	}
	return head tail
}

function convert_syntax(s, reg, len, tag,
	head, tail)
{
	head = ""
	tail = s
	while (match(tail, reg)) {
		head = head substr(tail, 1, RSTART - 1)
		head = head "<" tag ">"
		head = head substr(tail, RSTART + len, RLENGTH - len * 2)
		head = head "</" tag ">"
		tail = substr(tail, RSTART + RLENGTH)
	}
	return head tail
}

function convert_literals(s,
	head, tail, quoted)
{
	head = ""
	tail = s
	while (match(tail, /`[^`]*`/)) {
		quoted = substr(tail, RSTART + 1, RLENGTH - 2)
		head = head substr(tail, 1, RSTART - 1) "<code>" quoted "</code>"
		tail = substr(tail, RSTART + RLENGTH)
	}
	return head tail
}

function print_escaped(s)
{
	gsub("\\\\u", "_", s)
	gsub("\\\\q", "`", s)
	gsub("\\\\S", "[", s)
	gsub("\\\\s", "]", s)
	gsub("\\\\R", "(", s)
	gsub("\\\\r", ")", s)
	gsub("\\\\A", "\\&lt;", s)
	gsub("\\\\a", "\\&gt;", s)
	gsub("\\\\w", "*", s)
	gsub("\\\\e", "\\", s)
	print(s)
}

# **bold**, *italics*, links...

function convert_text(s)
{
	s = convert_syntax(s, "[*][*][^ ][^*]*[^ ][*][*]", 2, "strong")
	s = convert_syntax(s, "[*][^ ][^*]*[^ ][*]", 1, "em")
	s = convert_media(s)
	s = convert_links(s)
	s = convert_literals(s)
	return s
}

# Match the beginning of the line using the regexes REG[] defined in BEGIN
# to determine the printer to use.

HEADER && /^$/ {
	HEADER = 0
	next
}

HEADER {
	LINK[$1] = $2
	TEXT[$1] = $0
	sub("^[^ ]+ [^ ]* ", "", TEXT[$1])
	next
}

{
	gsub("&", "\\&amp;", s)
	gsub("<", "\\&lt;", s)
	gsub(">", "\\&gt;", s)
	gsub("\"", "\\&quot;", s)
}

sub("^\t", "", $0) {
	print_hook($0, "pre")
	print_escaped($0)
	next
}

sub("^\\* ", "", $0) {
	print_hook($0, "ul")
	print_escaped(sprintf("<li>%s</li>", convert_text($0)))
	next
}

sub("^[0-9]+. ", "", $0) {
	print_hook($0, "ol")
	print_escaped(sprintf("<li>%s</li>", convert_text($0)))
	next
}

match($0, "^#+ ") {
	print_hook($0 = substr($0, RLENGTH + 1), "")
	lv = RLENGTH - 1
	print("")
	print_escaped(sprintf("<h%d>%s</h%d>", lv, convert_text($0), lv))
	next
}

sub("^> ", "", $0) {
	print_hook($0, "blockquote")
	print_escaped(convert_text($0))
	next
}

{
	print_hook($0, "")
	print_escaped("<p>" convert_text($0) "</p>")
}

END {
	print_hook("", "")
}
