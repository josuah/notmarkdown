#!/usr/bin/awk -f
# convert links from a notmarkdown intermediate format to index.gph format

# This script only convert the "[ref]:" links.  The rest of the text
# is passed just escaped without other change.

BEGIN {
	HEADER = 1

	# the default is text, "0"
	EXT["gif"] = "g"
	EXT["jpg"] = EXT["jpeg"] = EXT["png"] = "I"
	EXT["cgi"] = EXT["dcgi"] = EXT["gph"] = "1"
}

# match the extension, and default to text/plain

function file_ext_type(s,
	x)
{
	if (s ~ "/$")
		return "1"
	for (x in EXT)
		if (tolower(s) ~ "\\."x"$")
			return EXT[x]
	return "0"
}

function parse_uri(s, link,
	i)
{
	if ((i = index(s, "://")) > 0) {
		link["proto"] = substr(s, 1, i - 1)
		s = substr(s, i + 3)
	}

	if ((i = index(s, "/"))) {
		link["host"] = substr(s, 1, i - 1)
		s = substr(s, i + 1)
	} else {
		link["host"] = s
		s = ""
	}

	if ((i = index(link["host"], ":"))) {
		link["port"] = substr(link["host"], i + 1)
		link["host"] = substr(link["host"], 1, i - 1)
	}

	link["path"] = "/" s
}

function strip_gopher_type(link)
{
	if (link["path"] == "/") {
		link["type"] = "1"
	} else {
		link["type"] = substr(link["path"], 2, 1)
		link["path"] = substr(link["path"], 3)
	}
}

function parse_link(s, link)
{
	link["host"] = "server"
	link["port"] = "port"
	link["desc"] = s

	if (s ~ "^//") {
		parse_uri(substr(s, 3), link)
		link["type"] = file_ext_type(link["path"])
		return
	}

	if (s ~ "^/") {
		link["path"] = s
		link["type"] = file_ext_type(link["path"])
		return
	}

	parse_uri(s, link)
	if (link["proto"] == "telnet") {
		link["type"] = "8"
	} else if (link["proto"] == "gopher") {
		strip_gopher_type(link)
	} else {
		link["type"] = "h"
		link["path"] = "URL:" s
	}
}

function print_escaped(s)
{
        gsub("\\\\u", "_", s)
        gsub("\\\\q", "`", s)
        gsub("\\\\S", "[", s)
        gsub("\\\\s", "]", s)
        gsub("\\\\R", "(", s)
        gsub("\\\\r", ")", s)
        gsub("\\\\A", "<", s)
        gsub("\\\\a", ">", s)
        gsub("\\\\w", "*", s)
        gsub("\\\\e", "\\", s)
        print(s)
}

function print_link_item(link, line,
	item)
{
	parse_link(link, item)
	item["line"] = line
	for (i in item)
		gsub(/\|/, "\\|", item[i])

	print_escaped(sprintf("[%s|%s|%s|%s|%s]", item["type"], item["line"],
	  item["path"], item["host"], item["port"]))
}

function fold_line(s, len)
{
	s = substr(s, 1, len + 1)
	sub(" *$", "", s)
	if (length(s) == len + 1)
		sub(" *[^ ]*$", "", s)
	return s
}

# assert that [ref] is smaller than [replacement text]

function print_text_line(pref, str, len,
	out, fold, ref, links, i)
{
	len -= length(pref)

	while (match(fold_line(str, len - length(out)), /\[[^] ]+\]/)) {
		links[ref = substr(str, RSTART + 1, RLENGTH - 2)]++
		out = out substr(str, 1, RSTART - 1) "[" TEXT[ref] "]"
		str = substr(str, RSTART + RLENGTH)
	}
	fold = fold_line(str, len - length(out))
	out = out fold
	str = substr(str, length(fold) + 1)
	sub("^ *", "", str)

	if (length(links) == 1)
		print_link_item(LINK[ref], pref out)
	if (length(links) != 1)
		print_escaped(pref out)
	if (length(links) >= 2)
		for (i in links)
			print_link_item(LINK[i], "    -> " TEXT[i])
	return str
}

function print_text_block(pref1, pref2, s,
	pref)
{
	print("")
	for (pref = pref1; length(s) > 0; pref = pref2)
		s = print_text_line(pref, s, 80)
}

HEADER && /^$/ {
	HEADER = 0
	next
}

HEADER {
	LINK[$1] = $2
	TEXT[$1] = $0
	sub("^[^ ]+ [^ ]* ", "", TEXT[$1])
	next
}

{
	BLOCK_PREV = BLOCK
	BLOCK = sub("^\t", "", $0)
	gsub(/\t/, "        ")
}

BLOCK {
	if (!BLOCK_PREV)
		print("")
	gsub(/\t/, "        ")
	print_escaped("  : " $0)
	next
}

sub("^\\* ", "", $0) {
	print_text_block("  • ", "    ", $0)
	next
}

sub("^[0-9]+. ", "", $0) {
	print_text_block(sprintf("%2s. ", $1), "    ", $0)
	next
}

match($0, "^#+ ") {
	print("\n")
	$0 = substr($0, RSTART + RLENGTH)
	if (RLENGTH == 1 + 1) {
		print_escaped("   " $0)
		gsub(".", "━", $0)
		print("  ━" $0 "━")
	} else if (RLENGTH == 2 + 1) {
		print_escaped($0)
		gsub(".", "─", $0)
		print($0)
	} else if (RLENGTH == 3 + 1) {
		print_escaped("═══ " $0 " ═══")
	} else if (RLENGTH == 4 + 1) {
		print_escaped("─── " $0 " ───")
	} else if (RLENGTH >= 5 + 1) {
		print_escaped("┈┈┈ " $0 " ┈┈┈")
	} else {
		print($0)
	}
	next
}

sub("^> ", "", $0) {
	print_text_block("  ┊ ", "  ┊ ", $0)
	next
}

{
	print_text_block(" ", " ", $0)
	next
}

END {
	print("\n")
}
