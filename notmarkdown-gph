#!/usr/bin/awk -f
# convert links from a notmarkdown intermediate format to index.gph format

# This script only convert the "[ref]:" links.  The rest of the text
# is passed just escaped without other change.

BEGIN {
	HEADER = 1

	# the default is text, "0"
	EXT["gif"] = "g"
	EXT["jpg"] = EXT["jpeg"] = EXT["png"] = "I"
	EXT["cgi"] = EXT["dcgi"] = EXT["gph"] = "1"
	EXT["mkv"] = EXT["webm"] = EXT["avi"] = EXT["mp4"] = "9"
	EXT["mka"] = EXT["opus"] = EXT["wav"] = EXT["mp3"] = "9"
}

# match the extension, and default to text/plain

function file_ext_type(s,
	x)
{
	if (s ~ "/$")
		return "1"
	for (x in EXT)
		if (tolower(s) ~ "\\."x"$")
			return EXT[x]
	return "0"
}

function parse_uri(s, link,
	i)
{
	if (i = index(s, "://")) {
		link["proto"] = substr(s, 1, i - 1)
		s = substr(s, i + 3)
	}

	if (i = index(s, "/")) {
		link["host"] = substr(s, 1, i - 1)
		s = substr(s, i + 1)
	} else {
		link["host"] = s
		s = ""
	}

	if (i = index(link["host"], ":")) {
		link["port"] = substr(link["host"], i + 1)
		link["host"] = substr(link["host"], 1, i - 1)
	}

	link["path"] = "/" s
}

function strip_gopher_type(link)
{
	if (link["path"] == "/") {
		link["type"] = "1"
	} else {
		link["type"] = substr(link["path"], 2, 1)
		link["path"] = substr(link["path"], 3)
	}
}

# vHost support on gopher if ENVIRON["VHOST"] is present

function gopher_vhost(link,
	s)
{
	if ("VHOST" in ENVIRON) {
		if (link["host"] == "")
			link["host"] = ENVIRON["VHOST"]
		if (i = index(link["host"] "$", "." ENVIRON["BASEDOM"]) "$") {
			s = substr(link["host"], i-1)
			link["path"] = "/" s link["path"]
			link["host"] = ENVIRON["BASEDOM"]
		} else {
			link["path"] = "/" link["host"] link["path"]
		}
	}
}

function parse_link(s, link)
{
	link["host"] = "server"
	link["port"] = "port"
	link["desc"] = s

	if (s ~ "^//") {
		parse_uri(substr(s, 3), link)
		link["type"] = file_ext_type(link["path"])
		gopher_vhost(link)
		return
	}

	if (s ~ "^/") {
		link["path"] = s
		link["type"] = file_ext_type(link["path"])
		gopher_vhost(link)
		return
	}

	parse_uri(s, link)
	if (link["proto"] == "telnet") {
		link["type"] = "8"
	} else if (link["proto"] == "gopher") {
		strip_gopher_type(link)
	} else {
		link["type"] = "h"
		link["path"] = "URL:" s
	}
}

function print_escaped(s)
{
	gsub("\\\\u", "_", s)
	gsub("\\\\q", "`", s)
	gsub("\\\\S", "[", s)
	gsub("\\\\s", "]", s)
	gsub("\\\\R", "(", s)
	gsub("\\\\r", ")", s)
	gsub("\\\\A", "<", s)
	gsub("\\\\a", ">", s)
	gsub("\\\\w", "*", s)
	gsub("\\\\e", "\\", s)
	print(s)
}

function print_link(link, line,
	item)
{
	parse_link(link, item)
	item["line"] = line
	for (i in item)
		gsub(/\|/, "\\|", item[i])

	print_escaped(sprintf("[%s|%s|%s|%s|%s]", item["type"], item["line"],
	  item["path"], item["host"], item["port"]))
}

function fold_line(s, len,
	head, tail, i)
{
	head = substr(s, 1, len + 1)
	sub(" *$", "", head)
	if (length(head) == len + 1)
		sub(" *[^ ]*$", "", head)
	if (length(head) == 0) {
		tail = substr(s, len + 1)
		head = substr(s, 1, len)
		if ((i = index(tail, " ")) == 0)
			return s
		return head substr(tail, 1, i)
	}
	return head
}

# assert that [ref] is smaller than [replacement text]

function print_line(pref, str, len,
	out, fold, ref, links, n)
{
	len -= length(pref)

	n = 0
	while (match(fold_line(str, len - length(out)), /\[[^] ]+\]/)) {
		n += (links[ref = substr(str, RSTART + 1, RLENGTH - 2)] = 1)
		out = out substr(str, 1, RSTART - 1) "[" TEXT[ref] "]"
		str = substr(str, RSTART + RLENGTH)
	}
	fold = fold_line(str, len - length(out))
	out = out fold
	str = substr(str, length(fold) + 2)

	if (n == 1)
		print_link(LINK[ref], pref out)
	if (n != 1)
		print_escaped(pref out)
	if (n >= 2)
		for (i in links)
			print_link(LINK[i], "    -> " TEXT[i])
	return str
}

function print_block(pref1, pref2, s,
	pref)
{
	for (pref = pref1; length(s) > 0; pref = pref2)
		s = print_line(pref, s, 80)
}

function print_blank()
{
	if (HEADING + 1 < NR)
		print("")
}

HEADER && /^$/ {
	HEADER = 0
	next
}

HEADER {
	LINK[$1] = $2
	TEXT[$1] = $0
	sub("^[^ ]+ [^ ]* ", "", TEXT[$1])
	next
}

{
	BLOCK_PREV = BLOCK
	BLOCK = sub("^\t", "", $0)
	gsub(/\t/, "        ")
}

BLOCK {
	if (!BLOCK_PREV)
		print_blank()
	gsub(/\t/, "        ")
	print_escaped(" ┊ " $0)
	next
}

sub("^\\* ", "", $0) {
	if (LIST < NR - 1)
		print_blank()
	print_block(" • ", "   ", $0)
	LIST = NR
	next
}

/^[0-9]+. / {
	print_blank()
	print_block($0, "   ", $0)
	next
}

match($0, "^#+ ") {
	HEADING = NR
	$0 = substr($0, RSTART + RLENGTH)
	print("")
	if (RLENGTH == 1 + 1) {
		print_block("", "", $0)
		gsub(".", "━", $0)
		print($0)
	} else if (RLENGTH == 2 + 1) {
		print_block("", "", $0)
		gsub(".", "─", $0)
		print($0)
	} else if (RLENGTH == 3 + 1) {
		print_block("═══ ", "", $0 " ═══")
	} else if (RLENGTH == 4 + 1) {
		print_block("─── ", "", $0 " ───")
	} else {
		print_block("┈┈┈ ", "", $0 " ┈┈┈")
	}
	next
}

sub("^> ", "", $0) {
	print_blank()
	print_block(" ┊ ", " ┊ ", $0)
	next
}

{
	print_blank()
	print_block(" ", " ", $0)
	next
}

END {
	print("\n")
}
